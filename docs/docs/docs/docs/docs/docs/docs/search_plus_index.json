{"./":{"url":"./","title":"Introduction","keywords":"","body":"计算机传统算法整理 本文档使用 Gitbook 制作 链接：https://44825762.github.io/Gitbook_public/ 贡献者 LGR - https://github.com/44825762 部分内容来自各大论坛，如有侵权请联系 44825762@163.com Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-09 03:07:27 "},"basic/algo/":{"url":"basic/algo/","title":"算法基础","keywords":"","body":"推荐资源 网站 LeetCode 力扣(LeetCode 中文) 领扣 LintCode 题解 LeetCode 题解(旧版，只有老题，已不再更新) LeetCode 题解(有新题，还在更新) 图解 LeetCode Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-12 08:12:42 "},"basic/algo/Array.html":{"url":"basic/algo/Array.html","title":"数组","keywords":"","body":"Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-14 08:35:25 "},"basic/algo/Linked-List.html":{"url":"basic/algo/Linked-List.html","title":"链表","keywords":"","body":"例题 单链表翻转 LeetCode 206 这个问题可以使用递归和非递归两种方法解决。 递归算法实现： ListNode* reverseList(ListNode* head) { if(NULL == head || NULL == head->next) return head; ListNode * p = reverseList(head->next); head->next->next = head; head->next = NULL; return p; } 非递归算法实现： ListNode* reverseList(ListNode* head) { ListNode *curr = head; if (curr == NULL) { return NULL; } ListNode *prev = NULL, *temp = NULL; while (curr != NULL) { temp = curr->next; curr->next = prev; prev = curr; curr = temp; } return prev; } 单链表判断是否有环 LeetCode 141 最容易想到的思路是存一个所有 Node 地址的 Hash 表，从头开始遍历，将 Node 存到 Hash 表中，如果出现了重复，则说明链表有环。 一个经典的方法是双指针（也叫快慢指针），使用两个指针遍历链表，一个指针一次走一步，另一个一次走两步，如果链表有环，两个指针必然相遇。 双指针算法实现： bool hasCycle(ListNode *head) { if (head == nullptr) { return false; } ListNode *fast,*slow; slow = head; fast = head->next; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow == fast) { return true; } } return false; } 单链表找环入口 LeetCode 141 作为上一题的扩展，为了找到环所在的位置，在快慢指针相遇的时候，此时慢指针没有遍历完链表，再设置一个指针从链表头部开始遍历，这两个指针相遇的点，就是链表环的入口。 算法实现： ListNode *detectCycle(ListNode *head) { if (head == nullptr) { return nullptr; } ListNode *fast,*slow; slow = head; fast = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow == fast) { ListNode *slow2 = head; while (slow2 != slow) { slow = slow->next; slow2 = slow2->next; } return slow2; } } return nullptr; } 单链表找交点 LeetCode 160 和找环的方法类似，同样可以使用 Hash 表存储所有节点，发现重复的节点即交点。 一个容易想到的方法是，先得到两个链表的长度，然后得到长度的差值 distance，两个指针分别从两个链表头部遍历，其中较长链表指针先走 distance 步，然后同时向后走，当两个指针相遇的时候，即链表的交点： int getListLength(ListNode *head) { if (head == nullptr) { return 0; } int length = 0; ListNode *p = head; while (p!=nullptr) { p = p->next; length ++; } return length; } ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { int lengthA = getListLength(headA); int lengthB = getListLength(headB); if (lengthA > lengthB) { std::swap(headA, headB); }; int distance = abs(lengthB - lengthA); ListNode *p1 = headA; ListNode *p2 = headB; while(distance--) { p2 = p2->next; } while (p1 != nullptr && p2 != nullptr) { if (p1 == p2) return p1; p1 = p1->next; p2 = p2->next; } return NULL; } 另一个较快的方法时，两个指针 pa，pb 分别从 headA，headB开始遍历，当 pa 遍历到尾部的时候，指向 headB，当 pb 遍历到尾部的时候，转向 headA。当两个指针再次相遇的时候，如果两个链表有交点，则指向交点，如果没有则指向 NULL： ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *pa = headA; ListNode *pb = headB; while (pa != pb) { pa = pa != nullptr ? pa->next : headB; pb = pb != nullptr ? pb->next : headA; } return pa; } 单链表找中间节点 LeetCode 876 用快慢指针法，当快指针走到链表结尾时，慢指针刚好走到链表的中间： ListNode* middleNode(ListNode* head) { ListNode *slow = head; ListNode *fast = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; } return slow; } 单链表合并 LeetCode 21 两个链表本身都是排序过的，把两个链表从头节点开始，逐个节点开始进行比较，最后剩下的节点接到尾部： ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) { if (l1 == nullptr) { return l2; } if (l2 == nullptr) { return l1; } ListNode dummy(-1); ListNode *p = &dummy; for (; l1 && l2; p = p->next) { if (l1->val val) { p->next = l1; l1 = l1->next; } else { p->next = l2; l2 = l2->next; } } p->next = l1 != nullptr ? l1 : l2; return dummy.next; } Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-12 08:12:42 "},"basic/algo/Tree.html":{"url":"basic/algo/Tree.html","title":"树","keywords":"","body":"基本知识 二叉树 二叉树：二叉树是有限个结点的集合，这个集合或者是空集，或者是由一个根结点和两株互不相交的二叉树组成，其中一株叫根的做左子树，另一棵叫做根的右子树。 二叉树的性质： 性质1：在二叉树中第 i 层的结点数最多为2^(i-1)（i ≥ 1） 性质2：高度为k的二叉树其结点总数最多为2^k－1（ k ≥ 1） 性质3：对任意的非空二叉树 T ，如果叶结点的个数为 n0，而其度为 2 的结点数为 n2，则：n0 = n2 + 1 满二叉树：深度为k且有2^k －1个结点的二叉树称为满二叉树 完全二叉树：深度为 k 的，有n个结点的二叉树，当且仅当其每个结点都与深度为 k 的满二叉树中编号从 1 至 n 的结点一一对应，称之为完全二叉树。（除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点） 性质4：具有 n 个结点的完全二叉树的深度为 log2n + 1 注意： 仅有前序和后序遍历，不能确定一个二叉树，必须有中序遍历的结果 堆 如果一棵完全二叉树的任意一个非终端结点的元素都不小于其左儿子结点和右儿子结点（如果有的话） 的元素，则称此完全二叉树为最大堆。 同样，如果一棵完全二叉树的任意一个非终端结点的元素都不大于其左儿子结点和右儿子结点（如果 有的话）的元素，则称此完全二叉树为最小堆。 最大堆的根结点中的元素在整个堆中是最大的； 最小堆的根结点中的元素在整个堆中是最小的。 哈弗曼树 定义：给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman tree)。 构造： 假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为： 将w1、w2、…，wn看成是有 n 棵树的森林(每棵树仅有一个结点)； 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和； 从森林中删除选取的两棵树，并将新树加入森林； 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。 二叉排序树 二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。 二叉排序树或者是一棵空树，或者是具有下列性质的二叉树： 若左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值； 左、右子树也分别为二叉排序树； 没有键值相等的节点 二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)（相当于顺序查找） 平衡二叉树 平衡二叉树（balanced binary tree）,又称 AVL 树。它或者是一棵空树,或者是具有如下性质的二叉树： 它的左子树和右子树都是平衡二叉树， 左子树和右子树的深度之差的绝对值不超过1。 平衡二叉树是对二叉搜索树(又称为二叉排序树)的一种改进。二叉搜索树有一个缺点就是，树的结构是无法预料的，随意性很大，它只与节点的值和插入的顺序有关系，往往得到的是一个不平衡的二叉树。在最坏的情况下，可能得到的是一个单支二叉树，其高度和节点数相同，相当于一个单链表，对其正常的时间复杂度有O(log(n))变成了O(n)，从而丧失了二叉排序树的一些应该有的优点。 B-树 B-树：B-树是一种非二叉的查找树， 除了要满足查找树的特性，还要满足以下结构特性： 一棵 m 阶的B-树： 树的根或者是一片叶子(一个节点的树),或者其儿子数在 2 和 m 之间。 除根外，所有的非叶子结点的孩子数在 m/2 和 m 之间。 所有的叶子结点都在相同的深度。 B-树的平均深度为logm/2(N)。执行查找的平均时间为O(logm)； Trie 树 Trie 树，又称前缀树，字典树， 是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。 Trie 树查询和插入时间复杂度都是 O(n)，是一种以空间换时间的方法。当节点树较多的时候，Trie 树占用的内存会很大。 Trie 树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。 例题 二叉树的遍历 二叉树前中后序遍历 二叉树的前中后序遍历，使用递归算法实现最为简单，以前序遍历（LeetCode 144）为例： void preorder(TreeNode *p, vector& result) { if (p == NULL) { return; } result.push_back(p->val); preorder(p->left, result); preorder(p->right, result); } vector preorderTraversal(TreeNode* root) { vector result; if (root == nullptr) { return result; } preorder(root, result); return result; } 二叉树的非递归遍历，主要的思想是使用栈（Stack）来进行存储操作，记录经过的节点。 非递归前序遍历（LeetCode 144）： vector preorderTraversal(TreeNode* root) { TreeNode *p = root; vector result; if (!p) { return result; } stack q; while (p || !q.empty()) { if (p) { result.push_back(p->val); q.push(p); p = p->left; } else { p = q.top(); q.pop(); p = p->right; } } return result; } 非递归中序遍历（LeetCode 94）： vector inorderTraversal(TreeNode* root) { TreeNode *p = root; vector result; if (!p) { return result; } stack q; while (p || !q.empty()) { if (p) { q.push(p); p = p->left; } else { p = q.top(); result.push_back(p->val); q.pop(); p = p->right; } } return result; } 非递归遍历中，后序遍历相对更难实现，因为需要在遍历完左右子节点之后，再遍历根节点，因此不能直接将根节点出栈。这里使用一个 last 指针记录上次出栈的节点，当且仅当节点的右孩子为空（top->right == NULL），或者右孩子已经出栈（top->right == last），才将本节点出栈： 非递归后序遍历（LeetCode 145）： vector postorderTraversal(TreeNode* root) { TreeNode *p = root; vector result; if (!p) { return result; } TreeNode *top, *last = NULL; stack q; while (p || !q.empty()) { if (p) { q.push(p); p = p->left; } else { top = q.top(); if (top->right == NULL || top->right == last) { q.pop(); result.push_back(top->val); last = top; } else { p = top->right; } } } return result; } 二叉树层序遍历 LeetCode 102 二叉树层序遍历有两种方法，分别是深度优先和广度优先： 深度优先（DFS）实现： void traversal(TreeNode *root, int level, vector> &result) { if (!root) { return; } // 保证每一层只有一个vector if (level > result.size()) { result.push_back(vector()); } result[level-1].push_back(root->val); traversal(root->left, level+1, result); traversal(root->right, level+1, result); } vector > levelOrder(TreeNode *root) { vector> result; traversal(root, 1, result); return result; } 广度优先（BFS）实现： vector> levelOrder(TreeNode* root) { std:queue q; TreeNode *p; vector> result; if (root == NULL) return result; q.push(root); while (!q.empty()) { int size = q.size(); vector levelResult; for (int i = 0; i val); if (p->left) { q.push(p->left); } if (p->right) { q.push(p->right); } } result.push_back(levelResult); } return result; } 二叉树子树 LeetCode 572 判断二叉树是否是另一棵二叉树的子树，使用递归实现： bool isSubtree(TreeNode* s, TreeNode* t) { if (!s) return false; if (sameTree(s, t)) return true; return isSubtree(s->left, t) || isSubtree(s->right, t); } bool sameTree(TreeNode* s, TreeNode* t) { if (!s && !t) return true; if (!s || !t) return false; if (s->val != t->val) return false; return sameTree(s->left, t->left) && sameTree(s->right, t->right); } 翻转二叉树 LeetCode 226 交互树的左右儿子节点，使用递归实现： TreeNode* invertTree(TreeNode* root) { if (root == nullptr) { return nullptr; } TreeNode *tmp = root->left; root->left = root->right; root->right = tmp; if (root->left) { invertTree(root->left); } if (root->right) { invertTree(root->right); } return root; } 参考资料 百度百科：哈弗曼树 百度百科：二叉排序树 百度百科：平衡二叉树 平衡二叉树及其应用场景 百度百科：B-树 前缀树 百度百科：前缀树 Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-12 08:12:42 "},"basic/algo/Hash-Table.html":{"url":"basic/algo/Hash-Table.html","title":"哈希表","keywords":"","body":"哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，哈希函数和冲突解决。 哈希函数 哈希函数也叫散列函数，它对不同的输出值得到一个固定长度的消息摘要。理想的哈希函数对于不同的输入应该产生不同的结构，同时散列结果应当具有同一性（输出值尽量均匀）和雪崩效应（微小的输入值变化使得输出值发生巨大的变化）。 冲突解决 现实中的哈希函数不是完美的，当两个不同的输入值对应一个输出值时，就会产生“碰撞”，这个时候便需要解决冲突。 常见的冲突解决方法有开放定址法，链地址法，建立公共溢出区等。实际的哈希表实现中，使用最多的是链地址法 链地址法 链地址法的基本思想是，为每个 Hash 值建立一个单链表，当发生冲突时，将记录插入到链表中。 例 2 设有 8 个元素 { a,b,c,d,e,f,g,h } ，采用某种哈希函数得到的地址分别为： {0 ， 2 ， 4 ， 1 ， 0 ， 8 ， 7 ， 2} ，当哈希表长度为 10 时，采用链地址法解决冲突的哈希表如下图所示： 参考资料 哈希表的 C 实现 解决哈希表的冲突-开放地址法和链地址法 Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-12 08:12:42 "},"basic/algo/Sorting.html":{"url":"basic/algo/Sorting.html","title":"排序","keywords":"","body":"排序算法的评价 稳定性 稳定排序算法会依照相等的关键（换言之就是值）维持纪录的相对次序。也就是一个排序算法是稳定的，就是当有两个有相等关键的纪录R和S，且在原本的串行中R出现在S之前，在排序过的串行中R也将会是在S之前。 计算复杂度（最差、平均、和最好表现） 依据串行（list）的大小（n），一般而言，好的表现是O(nlogn)，且坏的行为是O(n2)。对于一个排序理想的表现是O(n)。仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要O(nlogn)。 所有基于比较的排序的时间复杂度至少是 O(nlogn)。 常见排序算法 常见的稳定排序算法有： 冒泡排序（Bubble Sort） — O(n²) 插入排序（Insertion Sort）— O(n²) 桶排序（Bucket Sort）— O(n); 需要 O(k) 额外空间 计数排序 (Counting Sort) — O(n+k); 需要 O(n+k) 额外空间 合并排序（Merge Sort）— O(nlogn); 需要 O(n) 额外空间 二叉排序树排序 （Binary tree sort） — O(n log n) 期望时间; O(n²)最坏时间; 需要 O(n) 额外空间 基数排序（Radix sort）— O(n·k); 需要 O(n) 额外空间 常见的不稳定排序算法有： 选择排序（Selection Sort）— O(n²) 希尔排序（Shell Sort）— O(nlogn) 堆排序（Heapsort）— O(nlogn) 快速排序（Quicksort）— O(nlogn) 期望时间, O(n²) 最坏情况; 对于大的、乱数串行一般相信是最快的已知排序 冒泡排序 冒泡排序是最简单最容易理解的排序算法之一，其思想是通过无序区中相邻记录关键字间的比较和位置的交换,使关键字最小的记录如气泡一般逐渐往上“漂浮”直至“水面”。 冒泡排序的复杂度，在最好情况下，即正序有序，则只需要比较n次。故，为O(n) ，最坏情况下，即逆序有序，则需要比较(n-1)+(n-2)+……+1，故，为O(n²)。 乌龟和兔子 在冒泡排序中，最大元素的移动速度是最快的，哪怕一开始最大元素处于序列开头，也可以在一轮内层循环之后，移动到序列末尾。而对于最小元素，每一轮内层循环只能向前挪动一位，如果最小元素在序列末尾，就需要 n-1 次交换才能移动到序列开头。这两种类型的元素分别被称为兔子和乌龟。 代码实现： private static void BubbleSort(int[] array) { for (var i = 0; i array[j + 1]) // 若这里的条件是 >=，则变成不稳定排序 { Swap(array, j, j+1); } } } } 优化 在非最坏的情况下，冒泡排序过程中，可以检测到整个序列是否已经排序完成，进而可以避免掉后续的循环： private static void BubbleSort(int[] array) { for (var i = 0; i array[j + 1]) { Swap(array, j, j+1); swapped = true; } } if (!swapped) // 没有发生交互，证明排序已经完成 { break; } } } 进一步地，在每轮循环之后，可以确认，最后一次发生交换的位置之后的元素，都是已经排好序的，因此可以不再比较那个位置之后的元素，大幅度减少了比较的次数： private static void BubbleSort(int[] array) { var n = array.Length; for (var i = 0; i array[j + 1]) { Swap(array, j, j+1); newn = j + 1; // newn 以及之后的元素，都是排好序的 } } n = newn; if (n == 0) { break; } } } 更进一步地，为了优化之前提到的乌龟和兔子问题，可以进行双向的循环，正向循环把最大元素移动到末尾，逆向循环把最小元素移动到最前，这种优化过的冒泡排序，被称为鸡尾酒排序： private static void CocktailSort(int[] array) { var begin = 0; var end = array.Length - 1; while (begin array[j + 1]) { Swap(array, j, j + 1); newEnd = j + 1; } } end = newEnd - 1; for (var j = end; j > begin - 1; j--) { if (array[j] > array[j + 1]) { Swap(array, j, j + 1); newBegin = j; } } begin = newBegin + 1; } } 插入排序 插入排序也是一个简单的排序算法，它的思想是，每次只处理一个元素，从后往前查找，找到该元素合适的插入位置，最好的情况下，即正序有序(从小到大)，这样只需要比较n次，不需要移动。因此时间复杂度为O(n) ，最坏的情况下，即逆序有序，这样每一个元素就需要比较n次，共有n个元素，因此实际复杂度为O(n²) 。 算法实现： private static void InsertionSort(int[] array) { int i = 1; while (i 0 && array[j - 1] > array[j]) { Swap(array, j, j - 1); j--; } i++; } } 快排 快排是经典的 divide & conquer 问题，如下用于描述快排的思想、伪代码、代码、复杂度计算以及快排的变形。 快排的思想 如下的三步用于描述快排的流程： 在数组中随机取一个值作为标兵 对标兵左、右的区间进行划分(将比标兵大的数放在标兵的右面，比标兵小的数放在标兵的左面，如果倒序就反过来) 重复如上两个过程，直到选取了所有的标兵并划分(此时每个标兵决定的区间中只有一个值，故有序) 伪代码 如下是快排的主体伪代码 QUCIKSORT(A, p, r) if p 如下是用于选取标兵以及划分的伪代码 PARTITION(A, p, r) x = A[r] i = p - 1 for j = p to r - 1 if A[j] 代码 func quickSort(inout targetArray: [Int], begin: Int, end: Int) { if begin Int { let value = targetArray[end] var i = begin - 1 for j in begin .. 复杂度分析 在最好的情况下，每次 partition 都会把数组一分为二，所以时间复杂度 T(n) = 2T(n/2) + O(n) 解为 T(n) = O(nlog(n)) 在最坏的情况下，数组刚好和想要的结果顺序相同，每次 partition 到的都是当前无序区中最小(或最大)的记录，因此只得到一个比上一次划分少一个记录的子序列。T(n) = O(n) + T(n-1) 解为 T(n) = O(n²) 在平均的情况下，快排的时间复杂度是 O(nlog(n)) 变形 可以利用快排的 PARTITION 思想求数组中第K大元素这样的问题，步骤如下： 在数组中随机取一个值作为标兵，左右分化后其顺序为X 如果 X == Kth 说明这就是第 K 大的数 如果 X > Kth 说明第 K 大的数在标兵左边，继续在左边寻找第 Kth 大的数 如果 X 这个问题的时间复杂度是 O(n) T(n) = n + n/2 + n/4 + ... = O(n) 参考资料 各种基本排序算法的总结 常用排序算法小结 八大排序算法总结 QuickSort Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-12 08:12:42 "},"basic/algo/Chapter_2.html":{"url":"basic/algo/Chapter_2.html","title":"算法思想","keywords":"","body":"Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 22:18:15 "},"basic/algo/search.html":{"url":"basic/algo/search.html","title":"BFS DFS","keywords":"","body":"DFS BFS 深度优先搜索 广度优先搜索 DFS DFS思路 这是基本实现，后面还有双向DFS待补充 深度优先搜索，使用递归实现 大致算法模板： def dfs(a,b): if 判断是否达到目标，如果没有进行递归搜索 dfs():加入搜索方向，根据题意。 代码样例如下： 给定数组a,求和结果K，求是否可以得到K n = 5; a = [4,2,1,0,7]; k = 13; k2 = 15; def dfs(i,sum): if i == n: return sum == k; if dfs(i+1,sum): print(a[i]); return True; if dfs(i+1,sum+a[i]): print(a[i]); return True; return False; if(dfs(0,0)): print(\"yes\\n\"); else: print(\"NO\\n\") BFS 思路与DFS想通，但是实现略有不同。 关键因素： 记录搜索方向 例如：x = [0, 1,0，-1] y = [1, 0, -1, 0] 结合之后产生四个方向的坐标变化。 记录状态的队列： 一般使用队列实现，也可以使用数组实现。 状态记录主要记录访问过的点的坐标。 记录状态的队列就是搜索的队列以及顺序 距离记录 在一般的路径搜索，迷宫题目中需要找到最短的路径，加以修改可以返回迷宫路径 剩下就是和DFS差不多的条件判断及循环搜索 代码例子如下： N = 10; M = 10; # 0 - 墙壁 # 1 - 通道 # 3 - 起点 # 4 - 终点 A = [ [0,3,0,0,0,0,0,0,1,0], [1,1,1,1,1,1,0,1,1,0], [1,0,1,0,0,1,0,0,1,0], [1,0,1,1,1,1,1,1,1,1], [0,0,1,0,0,1,0,0,0,0], [1,1,1,1,0,1,1,1,1,0], [1,0,0,0,0,0,0,0,1,0], [1,1,1,1,0,1,1,1,1,1], [1,0,0,0,0,1,0,0,0,1], [1,1,1,1,0,1,1,1,4,0], ]; distance=[[9999 for i in range(10)] for j in range(10)] s = [0,1]; g = [9,8]; sx=s[0]; sy=s[1]; gx=g[0]; gy=g[1]; # 移动方向，4个方向 dx=[1, 0, -1, 0]; dy=[0, 1, 0, -1]; # 表示状态,标记是否访问过 state=[]; # 标记初始点为访问过的点 state.append([sx,sy]); # 设定距离为0 distance[sx][sy]=0; while len(state): point = state[0]; del state[0]; print(\"***\") print(state) # 判断是否找到出口 if A[point[0]][point[1]] == 4: #if point[0] == gx & point[1] == gy: print(\"YES\"); break; for i in range(0,4): x_index = point[0] + dx[i]; y_index = point[1] + dy[i]; # 判断移动条件以及是否访问过 if 0 Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 19:14:45 "},"basic/algo/DP.html":{"url":"basic/algo/DP.html","title":"动态规划","keywords":"","body":"动态规划 建议观看 MIT 算法导论-动态规划中的课程。 适用于动态规划的问题，需要满足最优子结构和无后效性，动态规划的求解过程，在于找到状态转移方程，进行自底向上的求解。 例题 爬楼梯问题 LeetCode 70 经典的动态规划问题之一，容易找到其状态转移方程为 dp[i] = dp[i-1] + dp[i-2]，从基础的 1 和 2 个台阶两个状态开始，自底向上求解： int climbStairs(int n) { if (n == 1) { return 1; } int* dp = new int[n+1](); dp[1] = 1; dp[2] = 2; for (int i = 3; i 从上面的代码中看到，dp[i] 只依赖 dp[i-1] 和 dp[i-2]，因此可以将代码简化： int climbStairs(int n) { int f0 = 1, f1 = 1, i, f2; for (i=2; i 容易看出其实结果就是 fibonacci 数列的第 n 项。 连续子数组的最大和 LeetCode 53 用 dp[n] 表示元素 n 作为末尾的连续序列的最大和，容易想到状态转移方程为dp[n] = max(dp[n-1] + num[n], num[n])，从第 1 个元素开始，自顶向上求解： int maxSubArray(vector& nums) { int* dp = new int[nums.size()](); dp[0] = nums[0]; int result = dp[0]; for (int i = 1; i 类似前一个问题，这个问题当中，求解 dp[i] 只依赖 dp[i-1]，因此可以使用变量来存储，简化代码： int maxSubArray(int A[], int n) { int result = INT_MIN; int f = 0; for (int i=0; i House Robber LeetCode 198 对于一个房子，有抢和不抢两种选择，容易得到状态转移方程 dp[i+1] = max(dp[i-1] + nums[i], dp[i])，示例代码如下： int rob(vector& nums) { int n = nums.size(); if (n == 0) { return 0; } vector dp = vector(n + 1); dp[0] = 0; dp[1] = nums[0]; for (int i = 1; i 同样的，可以使用两个变量简化代码： int rob(vector& nums) { int n = nums.size(); if (n == 0) { return 0; } int prev1 = 0; int prev2 = 0; for (int i = 0; i 最长回文子串 LeetCode 5 用 dp[i][j] 表示子串 i 到 j 是否是回文，使用动态规划求解： string longestPalindrome(string s) { int m = s.size(); if (m == 0) { return \"\"; } vector> dp(m, vector(m, 0)); int start = 0; int length = 1; for (int i = 0; i length) { start = i; length = j - i + 1; } } } } return s.substr(start, length); } 最小编辑距离 LeetCode 72 用 dp[i][j] 表示从 word[0..i) 转换到 word[0..j) 的最小操作，使用动态规划求解： int minDistance(string word1, string word2) { int m = word1.size(); int n = word2.size(); vector> dp(m + 1, vector(n + 1, 0)); // 全部删除，操作数量为 i for (int i = 0; i Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-12 08:12:42 "},"basic/algo/Greedy.html":{"url":"basic/algo/Greedy.html","title":"贪心","keywords":"","body":"贪心算法 建议观看MIT算法导论-贪心算法中的课程。 Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-12 08:12:42 "},"basic/algo/Chapter_3.html":{"url":"basic/algo/Chapter_3.html","title":"算法提高总纲","keywords":"","body":"Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 22:18:40 "},"basic/algo/Random.html":{"url":"basic/algo/Random.html","title":"随机","keywords":"","body":"洗牌算法 洗牌算法，顾名思义，就是只利用一次循环等概率的取到不同的元素(牌)。 如果元素存在于数组中，即可将每次 random 到的元素 与 最后一个元素进行交换，然后 count--，即可。 这相当于把这个元素删除，代码如下： #include #include using namespace std; const int maxn = 10; int a[maxn]; int randomInt(int a) { return rand()%a; } void swapTwoElement(int*x,int*y) { int temp; temp=*x; *x=*y; *y=temp; } int main(){ int count = sizeof(a)/sizeof(int); int count_b = count; srand((unsigned)time(NULL)); for (int i = 0; i Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-12 08:12:42 "},"Advanced/array/":{"url":"Advanced/array/","title":"算法进阶杂记","keywords":"","body":"算法基础 Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 13:06:00 "},"Advanced/array/Array.html":{"url":"Advanced/array/Array.html","title":"数组进阶","keywords":"","body":"数组 Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-07-22 13:04:33 "},"basic/Writing/English_writing.html":{"url":"basic/Writing/English_writing.html","title":"写作 - 连接词","keywords":"","body":"英文论文常用词 常用动词 show, present, illustrate, summarize, demonstrate, contain, provide, list, report, give, reveal, display, indicate, suggest, describe ... 引用 XXX + Verb. + n./that … 其中Verb可以为：state, claim, argue, maintain, suggest, assert, hypothesize, conclude, describe, develop, propose, find, show, report, use, study, demonstrate, note, discuss, observe, explain, expand, publish, give, examine, analyze, focus, presume, speculate, assume, support, theorize, contend, recommend 连接词分类： Additive transitions 提醒读者你要新增或参照其他资讯 Adversative transitions 指出信息之间的冲突或不一致 Causal transitions 指出后果和因果关系 Sequential transitions 澄清顺序和信息的序列和论文的整体架构 Additive Transitions这一类的转折皆表示在句子和段落之间有新信息加入，功能包含介绍或强调重点、参照先前提到的信息、加上新的状况或指名某一部分的信息是相当重要的。 目的 常用用法 常用句 范文 新增信息 Also; Additionally; Furthermore; Moreover In addition to; As well as; In fact; Not only…but also; As a matter of fact “Furthermore, the data shows that X is a significant factor.”“In addition to the above-mentioned study, Rogers also presents…” 介绍/强调 Particularly; Notably; Especially For example/instance; To illustrate; In particular; One example (of this is) “Notably, only two species of this fish survive.”“One example of this phenomenon is X.” 参照 Considering (this); Concerning (this); Regarding (this) As for (this); The fact that; With regards to (this); On the subject of (this); Looking at (this information) “Considering the amount of research in this area, little evidence has been found.”“With regards to the Blue Whale, its teeth are also the largest of any mammal.” 展现相似性 Similarly; Likewise; Equally By the same token; In the same way; In a similar way “Likewise, the algorithm was applied to Y.”“By the same token, this principle can be applied to Z.” 澄清/辨识重要信息 Specifically; Namely That is (to say); In other words; (To) put (it) another way; What this means is; This means (that) “There are two factors: namely, X and Y.”“In other words, the fall of the Empire was caused by over-expansion.” Adversative Transitions这些用法用来区分事实、论点和其他信息，可利用比对以展现相异处或提供反对论点、质疑某个事实或论点的重要性或替换并提供其他替换。 目的 常用用法 常用句 范文 比对/ 展现相异点 But; Still; However; While; Whereas; Conversely; (and) yet In contrast; On the contrary; On the other hand; …when in fact; By way of contrast “However, there is still more research needed.”“On the other hand, the 1997 study does not recognize these outcomes.” 辨别 / 强调 Indeed; Besides; Significantly; Primarily Even more; Above all; More/Most importantly “Indeed, a placebo is essential to any pharmaceutical study.”“Most importantly, the X enzyme increased.” 承认一个论点 Nevertheless; Nonetheless; Although; Despite (this); However; Regardless (of this); Admittedly Even so; Even though; In spite of (this); Notwithstanding (this); Be that as it may “Nevertheless, X is still an important factor.”“In spite of this fact, New York still has a high standard of living.”“Although this may be true, there are still other factors to consider.” 弱化论点或假说 Regardless (of) Either way; In any case; In any event; Whatever happens; All the same; At any rate “Regardless of the result, this fact is true.”“Either way, the effect is the same.”“In any event, this will not change the public’s view.” 替换 / 指出一个替换方法 Instead (of); (or) rather; (or) at least “Instead of using X, the scientists used Z.”“Or rather, why not implement a brand new policy?” Causal Transitions以下这些转折指出原因、条件、目的、前提和因果关系，通常出现于论文中的一个重要观点被建立之后或为了讨论假设性的关系或情况。 目的 常用用法 常用句 范文 表示一个起因或原因 Since; For; As; Because (of the fact that) Due to (the fact that); For the reason that; Owing to (the fact); Inasmuch as “Since the original sample group was too small, researchers called for more participants.”“Due to budgetary demands, funding will be cut in half.” 解释条件 If…then; Unless; Granting (that); Granted (that); Provided (that) In the event that; As/So long as; Only if “Unless these conditions change, more will need to be done.”“As long as there is oxygen, there will be oxygenation.” 展现效果/结果 Consequently; Therefore; Thus; Accordingly; Because (of this) As a result (of this); For this reason; As a consequence; So much (so) that “Therefore, we can conclude that this was an asymmetric catalysis.”“As a consequence, many consumers began to demand safer products.” 展现目的 For the purpose(s) of; With (this fact) in mind; In the hope that; In order that/to; So as to “For the purpose of following standards, X rule was observed.”“With the current state of pandas in mind, this study focused on preservation.” 强调前提的重要性 Otherwise Under those circumstances; That being the case; In that case; If so; All else being equal “Otherwise, this effect will continue into the future.”“All else being equal, the economic impact of this law seems positive.” Sequential Transitions这些转折将论文按照连续性或动作顺序组织架构，像是以参照先前提到的信息，以标示出额外插入的信息和以总结论文的方式。一连串的转折是建构架构的必经过程，帮助读者理解整个过程。 目的 常用用法 常用句 范文 以顺序做组织 Initially; Secondly; Thirdly; (First/Second/Third); Last First of all; To start with; In the (first/second/third) place “Initially, subjects were asked to write their names.”“First of all, dolphins are the smartest creatures in the sea.” 展现延续性 Subsequently; Previously; Afterwards; Eventually; Next; After (this) “Subsequently, subjects were taken to their rooms.”“Afterwards, they were asked about their experiences.” 总结/重复信息 (Once) again; Summarizing (this) To repeat; As (was) stated before; As (was) mentioned earlier/above “Summarizing this data, it becomes evident that there is a pattern.”“As mentioned earlier, pollution has become an increasing problem.” 暂时切换/再回归主题 Incidentally; Coincidentally; Anyway By the way; to resume; Returning to the subject; At any rate “Coincidentally, the methods used in the two studies were similar.”“Returning to the subject, this section will analyze the results.” 归结 / 总结 Thus; Hence; Ultimately; Finally; Therefore; Altogether; Overall; Consequently To conclude; As a final point; In conclusion; Given these points; In summary; To sum up “Ultimately, these results will be valuable to the study of X.”“In conclusion, there are three things to keep in mind—A, B, and C.” 按连接词的意义分类 目的 常用用法 表递进 moreover, in addition, what is more，furthermore, also, then, besides, etc. 表转折 however, nevertheless, on the other hand, on the contrary, etc. 表层次 on the one hand, ... on the other hand; first, ... second, ... finally; 表强调 firstly, ... secondly, ... finally ...; first, ... then ... etc. 表强调 in fact, indeed, actually, as a matter of fact, obviously, apparently, 表结果 evidently, first of all, undoubtedly, without any shadow of doubt, etc. 表结尾 therefore, as a result, then, consequently, accordingly, thus, etc. 表例举 in a word, in conclusion, therefore, in short, to sum up, etc. 表强调 still, Indeed, apparently, oddly enough, of course, after all, significantly, interestingly, also, above all, surely, certainly, undoubtedly, in any case, anyway, above all, in fact, especially. Obviously, clearly. 表比较 like, similarly, likewise, in the same way, in the same manner, equally. 表对比 by contrast, on the contrary, while, whereas, on the other hand, unlike, instead, but, conversely, different from, however, nevertheless, otherwise, whereas, unlike, yet, in contrast. 表列举 for example, for instance, such as, take ...for example. Except (for), to illustrate. 表时间 later, next, then, finally, at last, eventually, meanwhile, from now on, at the same time, for the time being, in the end, immediately, in the meantime, in the meanwhile, recently, soon, now and then, during, nowadays, since, lately, as soon as, afterwards, temporarily, earlier, now, after a while. first after a few days eventually at that time in the meantime meanwhile afterward from then on 表顺序 first, second, third, then, finally, to begin with, first of all, in the first place, last, next, above all, last but not the least, first and most important. 表可能 presumably, probably, perhaps. 表解释 in other words, in fact, as a matter of fact, that is, namely, in simpler terms. 表递进 What is more, in addition, and, besides, also, furthermore, too, moreover, furthermore, as well as, additionally, again. 表让步 although, after all, in spite of..., despite, even if, even though, though, admittedly, whatever may happen. 表转折 however, rather than, instead of, but, yet, on the other hand, unfortunately. whereas 表原因 for this reason, due to, thanks to, because, because of, as, since, owing to. 表结果 as a result, thus, hence, so, therefore, accordingly, consequently, as consequence. 表总结 on the whole, in conclusion, in a word, to sum up, in brief, in summary, to conclude, to summarize, in short. 其他类型连接词 Mostly, occasionally, currently, naturally, mainly, exactly, evidently, frankly, commonly, for this purpose, to a large extent, for most of us, in many cases, in this case, 表空间 near to far from in the front of beside behind to the right to the left on the other side of 表举例 for example to name a few, say , such as 表递进 in addition furthermore what’s more what’s worse 表对比 whereas while as opposed to by contrast by comparison 表示时间与频率的词汇: in general, every, some, after, on the whole, usually, most, at other times, in most cases, frequently, main, finally, as a rule, rarely, before, meanwhile. 表示附加的词: additionally, as well as, just as, again, along with, also, further, furthermore, likewise, in the same manner, in the same way, in addition to, 引出例子: for example, namely, for instance, as an example, that is 表示转折: although, instead, rather than, but, nevertheless, though, however, on the other hand, otherwise 得出结论: all in all, in consequence, in brief, as a result, the point is, in conclusion, therefore, hence, in sum. 表示增加的过渡词： also，and，and then，too，in addition，furthermore，moreover，again，on top of that，another，first second third等。 表示时间顺序的过渡词： now，then，before，after，afterwards，earlier，later，immediately，soon，next，in a few days，gradually，suddenly，finally等。 表示空间顺序的过渡词： near（to），far（from），in front of，behind，beside，beyond，above，below，to the right （left），around，outside等。 表示比较的过渡词： in the same way，just like，just as等。 表示对照的过渡词： but，still，yet，however，on the other hand，on the contrary，in spite of，even though等。 表示结 果 和 原 因 的 过 渡 词： because，since，so，as a result，therefore，hence，thus，otherwise等。 表示目的的过渡词： for this reason，for this purpose，so that等。 表示强调的过渡词： in fact，indeed，surely，necessarily，certainly，without any doubt，truly，to repeat，above all，most important等。 表示解释说明的过渡词： for example，in fact，in this case，for actually等。 表示总结的过渡词： finally，at last，in conclusion，as I have shown，in other word，in brief，in short，in general，on the whole，as has been stated等 增补(Addition) in addition, furthermore, again, also, besides, moreover, what’s more, similarly, next, finally. 比较(Comparison) in the same way, likewise, similarly, equally, in comparison, just as 对照(Contrast) whereas, in contrast, on the other hand, instead, however, nevertheless, unlike, even though, on the contrary, while 因果(Cause and effect) because, because of, for, since, due to, owing to, thanks to, as a result (of), accordingly, hence, so, thus 强调(Emphasis) certainly, above all, indeed, of course, surely, actually, as a matter of fact, chiefly, especially, primarily, in particular, undoubtedly, absolutely, most important 6.让步(Concession) although, though, after all, in spite of, nevertheless, still, provided, while it is true.... 7.例证(Exemplification) for example, for instance, that is, namely, such as, in other words, in this case, by way of illustration. 总结(Conclusion) to sum up, to conclude, in a word, in short, in brief, all in all, in all, to put it in a nut shell, in summary 推断(Inference) therefore, as a result(of), consequently, accordingly, so, otherwise 时间和空间(Time and space) afterward, after, first, later, then, soon, outside, near, beyond, above, below, on the right(left), in the middle, opposite, in front of 表示罗列增加（递进） first, second, third, firstly, secondly, thirdly, first, then / next, after that / next, finally / last / last but not least, and equally important, on (the) one hand…, on the other hand…, besides / what’s more / in addition (to sth.) / furthermore / moreover / another / also / too, plus, as well, especially / particularly / in particular 表示时间顺序 now, at present, recently, after, afterwards, after that, after a while, in a few days, at first, at the beginning (of sth.), to begin with, to start with,later, next, finally, immediately, soon, suddenly = all of a sudden, at that moment, as soon as, the moment…, form now on, from then on, gradually,at the same time = meanwhile, till, not…until, before, after, when, while, as, during 表示解释说明 now, in addition, for example, for instance, in this case, in fact / as a matter of fact / actually, frankly speaking, in other words, in simpler terms, that is to say, to put it differently 表示转折关系 but, however, while, though, yet, still, nevertheless, or, otherwise, on the contrary / on the other hand, in spite of… / despite the fact that…, even though, except (for), instead, in stead of, of course, after all, even so 表示并列关系 or, and, also, too, not only … but also…, as well as, both… and…, either …or…, neither…nor… 表示因果关系 原因： because, because of = thanks to… = due to… = owing to…, since = now that, as, for, 结果： so, therefore, thus, hence, as a result (of), on this / that account, so…that, such…that, in this way 表示条件关系 as (so) long as, on condition that, if, unless 表示让步关系 though， although， as， even if， even though， whether …or…， however， whoever, whatever, whichever, wherever, whenever, no matter how (who, what, which, where) 表示举例 for example, for instance, such as…, like…, take… for example 表示比较 be similar to, similarly, the same as, in contrast, compared with (to)…, just like 表示目的 for this reason, for this purpose, so that, in order that, in order to, so as to, 表示强调 indeed, in fact, surely, certainly, no doubt, without any doubt, truly, obviously, above all 表示概括归纳 in a word, in short, in brief, in summary, on the whole, generally speaking, in general, in my opinion, as far as I am concerned, as what has been mentioned, to sum up, to conclude, in conclusion 表示“尤有进者”的意思： Again, also, then, besides, further, furthermore, moreover, next, in addition等，如：① Jason teaches diligently. Besides, he writes a lot. ② English is a useful language. For one thing, it is an official language in the UN. Then, it is widely used in business, science and technology. 表示“反意见”： But, however, still, yet, after all, for all that, in spite of, on the contrary, on the other hand等，如：③ Jim is intelligent but lazy.　④ Singapore is not a big country. On the contrary, it is very small. 表示“困果关系”： Therefore, so, hence, thus, accordingly, consequently, as a result 等，如：　⑤ Some people are over-ambitious. As a result, they are usually unhappy.　⑥ Tom did not work hard; hence, he failed. 表示“比较关系”： Likewise, similarly, in a like manner 等，如：　⑦ You cannot writes without a pen. Likewise, you cannot cook without rice.　⑧ No one is allowed to speak Mandarin in an English class. Similarly, no one is allowed to speak English in a Mandarin class. 表示“举例示范”： For example, in other words, for instance, that is 等，如：　⑨ There are some common errors in his composition. For instance, it is wrong to use \"he\" to replace \"the queen\". 表示“结束”： To sum up, in brief, in short, on the whole, to conclude 等，如：　⑩ Some say Singapore is a nice place to live in. Others say it is not so nice. It is too competitive. In short, some like Singapore; some do not. 并列关系 and, furthermore, more than that, also, likewise, moreover, in addition, what is more, for instance, for example 转折关系 although, however, on the contrary, but, in spite of, nevertheless, yet, otherwise, despite 顺序关系 first, second, third, and so on, then, after, before, next 因果关系 as a result, for, thus, because, for this reason, so, therefore, as, since, consequently, on account of 归纳关系 as a result, finally, therefore, accordingly, in short, thus, consequently, in conclusion, so, in brief, in a word 几个用得比较多的句子： As far as I am concerned, the advantages of … outweigh its disadvantages. Nevertheless, the disadvantages of … is undeniable. To sum up/ In general/ On the whole/ In brief/ In short/ In a word, it is true that … bring about both positive and negative results. But we can try our best to reduce the negative influence to the least extent. Obviously, in every aspect, …This diagram unfolds a clear comparison between…and…. As to the other three, though the growth rates were not so high, they were indeed remarkable and impressive. 表层进\\表举例\\表解释\\表总结\\表强调\\表让步\\表比较\\表转折\\表时间\\表层进 first, firstly to begin with second, secondly to start with,third, thirdly what’s more,also and then,and equally important,besides in addition,further in the first place,still furthermore,last last but not the least,next besides,too moreover,finally 2. 表举例 for example for instance,to illustrate as an illustration,after all 　 3. 表解释 as a matter of fact frankly speaking,in this case namely,in other words 　 4. 表总结 in summary in a word,in brief in conclusion,to conclude in fact,indeed in short,in other words of course,it is true specially,namely in all,that is to summarize,thus as has been said,altogether in other words,finally in simpler terms,in particular that is,on the whole to put it differently,therefore 　 5. 表强调 of course indeed,above all most important,emphasis certainly in fact 6. 表让步 still nevertheless,in spite of all the same,even so after all,concession granted naturally,of course 　 7. 表比较 in comparison likewise,similarly equally,however likewise,in the same way 　 8. 表转折 by contrast although,at the same time but,in contrast nevertheless,notwithstanding on the contrary,on the other hand otherwise,regardless still,though yet,despite the fact that even so,even though for all that,however in spite of,instead 　 9. 表时间 after a while afterward,again also,and then as long as,at last at length,at that time before,besides earlier,eventually finally,formerly further,furthermore in addition,in the first place in the past,last lately,meanwhile moreover,next now,presently second,shortly simultaneously,since so far,soon still,subsequently then,thereafter too,until until now,when 总结关系过渡词语 in general, to some extent, in my view, as for me, as far as I am concerned, obviously, in brief, on the whole 比较对比关系过渡词语 similarly, on the contrary, on the one hand, on the other hand, otherwise, in sharp contrast, but, however, yet, nevertheless 列举关系过渡词语 as a case in point, such as, first of all, to begin with, furthermore, besides, in addition, for one thing, for another 因果关系过渡词语 because (of), since, for, owing to, thanks to, as a result of, consequently, for the reason that, therefore, hence 让步关系过渡词语 although, even though, in spite of, despite 强调关系过渡词语 surely, obviously, particularly, in deed, needless to say, most important of all 递进关系 in addition, also, moreover, besides，what's more 时间顺序 immediately, meanwhile, presently, shortly, since, soon, temporarily, while 方式手段 as, as if, the way，by 目的关系 so that, lest，in order that 1)表层次: First ,firstly, to begin with, further, in the first place,second, secondly, to start with, still, furthermore,third, thirdly, what is more, last, last but not least,also, and then, next, besides,and equally important too moreover,besides in addition finally 2)表转折； by contrast although though yet,at the same time but despite the fact that even so,in contrast nevertheless even though for all that,notwithstanding on the contrary however in spite of,on the other hand otherwise instead still,regardless 3)表因果； therefore consequently because of for the reason,thus hence due to owing to,so accordingly thanks to on this account,since as on that account in this way,for as a result as a consequence 4）表让步： still nevertheless concession granted naturally,in spite of all the same of course despite,even so after all 5)表递近： furthermore moreover likewise what is more,besides also not only...but also...,too in addition 6)表举例： for example for instance for one thing that is,to illustrate as an illustration a case in point 7)表解释： as a matter of fact frankly speaking in this case namely,in other words 8)表总结： in summary in a word thus as has been said,in brief in conclusion altogether in other words,to conclude in fact finally in simpler terms,indeed in short in particular that is,in other words of course on the whole to put it differently,namely in all therefore to summarize 表并列补充关系: what is more, besides, also, as well, moreover, furthermore, in addition 表转折对比关系: but, however, yet, instead, on the other hand, on the contrary, although, different from, in contrast to, despite, in spite of, whereas, un?鄄like, nevertheless, not only...but also, here...there, years ago...today, this...that, the former...the latter, then...now, the first...whereas the second, once...now, on the one hand...on the other , some...others 表因果关系: since, as, because （of）, for, so, thus, therefore, as a result, so that 表条件关系: if, on the condition （that）, as long as, unless, or else 表时间关系: when, after, before, until, as soon as, later, afterwards, soon, lately, recently, since, from then on, eventually, in the meantime, then, suddenly, at the same time, next, early this morning/year/century, after an interval, now, after, presently, later, after?鄄ward, somewhat later, finally, at last, all of a sudden 表特定的顺序关系: above all, first of all, firstly, first, secondly, the , next, finally, in the end, at last 表换一种方式表达: in other words, that is to say, to put it another way 表举例说明: for instance, for example, like, such as 表陈述事实: in fact, actually, as a matter of fact, to tell you the truth 表总结: on the whole, in short, all in all, general, in a word, in conclusion, in closing, in summary Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-08-09 03:02:48 "},"basic/Writing/Tour.html":{"url":"basic/Writing/Tour.html","title":"爱丁堡","keywords":"","body":"Hello, professors. I am GUORONG LI, and my supervisor is Dr. Raphael Jeffery. It is my great honor to participate in the project presentation. My project is to explore the Effect of Facial Partitioning Method on Facial Recognition. （进入目录） The project will be introduced in four parts, which are the scope, contributions, demonstration, and conclusion. (进入intro) First of all, scope. After the COVID-19 happened, identity masked people become a crucial problem, and it can be changed to the task that recognizes people by their facial components. This project aims to explore the effect of only encoding single facial components as features on the capability of LBPH facial recognition algorithm to identify face images. (进入contribution) After that, the contributions. There are four main contributions in this project, and I will describe them one by one. (contributions - 1 - Dataset segmentation) The contribution one is to segment and make new datasets. In this step, we divided the images in the AT&T dataset and made them as four new datasets by the area of facial components. Here is an example, as seen in the images, the front face image is coming from AT&T dataset, and his name is marked as S34. According to the different facial components area, we divided his facial component into four parts, and these four parts will be four datasets. Applying this process for each image in the AT&T dataset, we will obtain the four new datasets. (contributions - 2 - implement the LBPH algorithm and classifier) The contribution two is to implement the LBPH algorithm and classifier. Contribute two is about code implementation, so we jump to contribute three. (contributions - 3 - The controlled experiment design and application) The contribution three is to design the controlled experiment and apply experiment. This part shows how we design the experiment. There are one control group and four experimental groups. The control group is the one using AT&T dataset as training images to train the LBPH classifier. The experimental group is to use each facial component datasets to train the LBPH classifier. Considering the variability, we will train each classifier ten times and take the average accuracy rate value as the final result because the data selection in the training process is random. (contributions - 4 - evaluate the experiment) The contribution four is to show the result and evaluate the experiment. Here is the result of the experiment. The evaluation method combines the characteristic of the LBPH algorithm, the accuracy of each classifier, and the similarity and distance between images within the same dataset. The approach of the LBPH algorithm to check whether the images matched something in the dataset is to compare the histogram of an input image and the histograms of images in the dataset. So, a large distance means a significant difference between images and it may make the LBPH model match nothing. Here I just pick jaw and nose as an example. The nose's accuracy rate is 80.92%, the similarity is 84.96%, and the distance is 38.5. It means that there are 84.96% of pixels in images are the same on average. Meanwhile, the difference between the different pixels in images is not changed much. Combining this property and the characteristic of the LBPH algorithm, the algorithm can catch the tiny difference and do classification correctly. Therefore, the nose group can gain high accuracy. However, the Jaw group has a low similarity and high distance. It means the content of images is not similar, and the content has a big difference. Hence, the difference between images is too big for the LBPH algorithm to catch. So, we can see that the jaw group has the lowest accuracy. (Demonstration) Then, the demonstration. This project can help people to recognize people by their facial components. Here, I put my images in AT&T and apply the method proposed in this project to test whether it can recognition me using my single facial components. The result is shown in the video. Only the jaw group misclassified, and all the other facial component groups are classified correctly. (conclusion) Finally, conclusion. In conclusion, only encoding facial components as a feature to identify face images with the LBPH algorithm is works. According to the experiment result, if not chose jaw as a feature, the accuracy rate of recognizing people correctly is 74.5% - 80.92%. (进入感谢页) Thank you for watching my presentation. Copyright © GUORONG LI 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-09-02 17:52:02 "}}